<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON SERPENT</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #0a0a0f;
            font-family: 'Orbitron', monospace;
            overflow: hidden;
        }

        /* Animated background grid */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(90deg, rgba(0, 255, 136, 0.03) 1px, transparent 1px),
                linear-gradient(rgba(0, 255, 136, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            animation: gridPulse 4s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Scanline effect */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.1) 2px,
                rgba(0, 0, 0, 0.1) 4px
            );
            pointer-events: none;
            z-index: 1000;
        }

        .game-container {
            position: relative;
            z-index: 1;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2rem, 6vw, 3.5rem);
            font-weight: 900;
            text-align: center;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #00ff88, #00d4ff, #ff00aa);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
            text-shadow: 0 0 40px rgba(0, 255, 136, 0.5);
            letter-spacing: 0.2em;
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .score-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 420px;
            margin-bottom: 1rem;
            padding: 0.75rem 1.5rem;
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 4px;
        }

        .score-item {
            text-align: center;
        }

        .score-label {
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.7rem;
            color: rgba(0, 255, 136, 0.6);
            letter-spacing: 0.15em;
            margin-bottom: 0.25rem;
        }

        .score-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
        }

        .high-score .score-value {
            color: #ff00aa;
            text-shadow: 0 0 20px rgba(255, 0, 170, 0.8);
        }

        #gameCanvas {
            display: block;
            border: 2px solid #00ff88;
            border-radius: 4px;
            box-shadow: 
                0 0 30px rgba(0, 255, 136, 0.3),
                inset 0 0 60px rgba(0, 0, 0, 0.5);
            background: linear-gradient(135deg, #0d0d12 0%, #0a0a0f 100%);
        }

        .controls-hint {
            margin-top: 1.5rem;
            text-align: center;
        }

        .controls-hint p {
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.75rem;
            color: rgba(0, 255, 136, 0.5);
            letter-spacing: 0.1em;
        }

        .key-hints {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 0.75rem;
        }

        .key {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 4px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.8rem;
            color: #00ff88;
            transition: all 0.15s ease;
        }

        .key.active {
            background: rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
            transform: scale(0.95);
        }

        .arrow-keys {
            display: grid;
            grid-template-columns: repeat(3, 36px);
            grid-template-rows: repeat(2, 36px);
            gap: 4px;
            margin-left: 1rem;
        }

        .arrow-keys .key:nth-child(1) { grid-column: 2; }
        .arrow-keys .key:nth-child(2) { grid-column: 1; grid-row: 2; }
        .arrow-keys .key:nth-child(3) { grid-column: 2; grid-row: 2; }
        .arrow-keys .key:nth-child(4) { grid-column: 3; grid-row: 2; }

        /* Game Over Overlay */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 15, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            border-radius: 4px;
        }

        .overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .overlay h2 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            font-weight: 900;
            color: #ff0055;
            text-shadow: 0 0 30px rgba(255, 0, 85, 0.8);
            margin-bottom: 1rem;
            letter-spacing: 0.15em;
        }

        .overlay.start h2 {
            color: #00ff88;
            text-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
        }

        .overlay p {
            font-family: 'Share Tech Mono', monospace;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 0.5rem;
        }

        .final-score {
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: 700;
            color: #00d4ff;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.8);
            margin: 1rem 0;
        }

        .play-btn {
            margin-top: 1.5rem;
            padding: 1rem 2.5rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            letter-spacing: 0.2em;
            color: #0a0a0f;
            background: linear-gradient(135deg, #00ff88, #00d4ff);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .play-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.4);
        }

        .play-btn:active {
            transform: translateY(0);
        }

        .new-high-score {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: #ff00aa;
            text-shadow: 0 0 20px rgba(255, 0, 170, 0.8);
            animation: pulse 0.5s ease infinite alternate;
            margin-top: 0.5rem;
        }

        @keyframes pulse {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }

        /* Mobile touch controls */
        .touch-controls {
            display: none;
            margin-top: 1.5rem;
        }

        @media (pointer: coarse) {
            .touch-controls {
                display: block;
            }
            .controls-hint {
                display: none;
            }
        }

        .touch-grid {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 8px;
        }

        .touch-btn {
            background: rgba(0, 255, 136, 0.15);
            border: 2px solid rgba(0, 255, 136, 0.4);
            border-radius: 8px;
            color: #00ff88;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s ease;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .touch-btn:active {
            background: rgba(0, 255, 136, 0.4);
            transform: scale(0.95);
        }

        .touch-btn.empty {
            background: transparent;
            border-color: transparent;
        }

        /* Footer */
        .footer {
            margin-top: 2rem;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.7rem;
            color: rgba(0, 255, 136, 0.3);
            letter-spacing: 0.1em;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>NEON SERPENT</h1>
        
        <div class="score-panel">
            <div class="score-item">
                <div class="score-label">SCORE</div>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="score-item high-score">
                <div class="score-label">HIGH SCORE</div>
                <div class="score-value" id="highScore">0</div>
            </div>
        </div>

        <div style="position: relative;">
            <canvas id="gameCanvas" width="400" height="400"></canvas>
            
            <div class="overlay start visible" id="overlay">
                <h2 id="overlayTitle">NEON SERPENT</h2>
                <p id="overlayMessage">Guide the serpent. Consume the light.</p>
                <div class="final-score" id="finalScore" style="display: none;">0</div>
                <div class="new-high-score" id="newHighScore" style="display: none;">★ NEW HIGH SCORE ★</div>
                <button class="play-btn" id="playBtn">START GAME</button>
            </div>
        </div>

        <div class="controls-hint">
            <p>CONTROLS</p>
            <div class="key-hints">
                <div style="display: flex; gap: 4px;">
                    <div class="key" id="keyW">W</div>
                    <div class="key" id="keyA">A</div>
                    <div class="key" id="keyS">S</div>
                    <div class="key" id="keyD">D</div>
                </div>
                <div class="arrow-keys">
                    <div class="key" id="keyUp">↑</div>
                    <div class="key" id="keyLeft">←</div>
                    <div class="key" id="keyDown">↓</div>
                    <div class="key" id="keyRight">→</div>
                </div>
            </div>
        </div>

        <div class="touch-controls">
            <div class="touch-grid">
                <div class="touch-btn empty"></div>
                <div class="touch-btn" data-dir="up">↑</div>
                <div class="touch-btn empty"></div>
                <div class="touch-btn" data-dir="left">←</div>
                <div class="touch-btn empty"></div>
                <div class="touch-btn" data-dir="right">→</div>
                <div class="touch-btn empty"></div>
                <div class="touch-btn" data-dir="down">↓</div>
                <div class="touch-btn empty"></div>
            </div>
        </div>

        <div class="footer">© 2025 NEON SERPENT</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const overlay = document.getElementById('overlay');
        const overlayTitle = document.getElementById('overlayTitle');
        const overlayMessage = document.getElementById('overlayMessage');
        const finalScore = document.getElementById('finalScore');
        const newHighScore = document.getElementById('newHighScore');
        const playBtn = document.getElementById('playBtn');

        // Game settings
        const gridSize = 20;
        const tileCount = canvas.width / gridSize;
        
        // Game state
        let snake = [];
        let food = { x: 0, y: 0 };
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let score = 0;
        let highScore = localStorage.getItem('neonSerpentHighScore') || 0;
        let gameRunning = false;
        let gameLoop = null;
        let speed = 100;

        // Particles
        let particles = [];

        highScoreEl.textContent = highScore;

        // Initialize game
        function initGame() {
            snake = [
                { x: 5, y: 10 },
                { x: 4, y: 10 },
                { x: 3, y: 10 }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            speed = 100;
            scoreEl.textContent = score;
            particles = [];
            spawnFood();
        }

        // Spawn food at random position
        function spawnFood() {
            do {
                food.x = Math.floor(Math.random() * tileCount);
                food.y = Math.floor(Math.random() * tileCount);
            } while (snake.some(seg => seg.x === food.x && seg.y === food.y));
        }

        // Create particle explosion
        function createParticles(x, y, color) {
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 / 12) * i;
                particles.push({
                    x: x * gridSize + gridSize / 2,
                    y: y * gridSize + gridSize / 2,
                    vx: Math.cos(angle) * (2 + Math.random() * 3),
                    vy: Math.sin(angle) * (2 + Math.random() * 3),
                    life: 1,
                    color: color
                });
            }
        }

        // Update particles
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.03;
                return p.life > 0;
            });
        }

        // Draw particles
        function drawParticles() {
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3 * p.life, 0, Math.PI * 2);
                ctx.fillStyle = p.color.replace('1)', `${p.life})`);
                ctx.fill();
            });
        }

        // Game update
        function update() {
            direction = { ...nextDirection };
            
            // Move snake
            const head = {
                x: snake[0].x + direction.x,
                y: snake[0].y + direction.y
            };

            // Wall collision (wrap around)
            if (head.x < 0) head.x = tileCount - 1;
            if (head.x >= tileCount) head.x = 0;
            if (head.y < 0) head.y = tileCount - 1;
            if (head.y >= tileCount) head.y = 0;

            // Self collision
            if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
                gameOver();
                return;
            }

            snake.unshift(head);

            // Food collision
            if (head.x === food.x && head.y === food.y) {
                score += 10;
                scoreEl.textContent = score;
                createParticles(food.x, food.y, 'rgba(0, 212, 255, 1)');
                spawnFood();
                
                // Speed up slightly
                if (speed > 50) {
                    speed -= 2;
                    clearInterval(gameLoop);
                    gameLoop = setInterval(gameStep, speed);
                }
            } else {
                snake.pop();
            }
        }

        // Draw game
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw subtle grid
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // Draw food with glow
            const foodX = food.x * gridSize + gridSize / 2;
            const foodY = food.y * gridSize + gridSize / 2;
            
            // Outer glow
            const gradient = ctx.createRadialGradient(foodX, foodY, 0, foodX, foodY, gridSize);
            gradient.addColorStop(0, 'rgba(0, 212, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(0, 212, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 212, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(food.x * gridSize - gridSize/2, food.y * gridSize - gridSize/2, gridSize * 2, gridSize * 2);
            
            // Food core
            ctx.fillStyle = '#00d4ff';
            ctx.shadowColor = '#00d4ff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(foodX, foodY, gridSize / 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Draw snake
            snake.forEach((seg, i) => {
                const x = seg.x * gridSize;
                const y = seg.y * gridSize;
                const padding = 2;
                
                // Calculate color gradient from head to tail
                const progress = i / snake.length;
                const hue = 140 + progress * 20; // Green to teal
                const lightness = 60 - progress * 20;
                const alpha = 1 - progress * 0.3;
                
                if (i === 0) {
                    // Head with extra glow
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#00ff88';
                } else {
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = `hsla(${hue}, 100%, ${lightness}%, ${alpha})`;
                }
                
                // Rounded rectangle for each segment
                const radius = i === 0 ? 6 : 4;
                ctx.beginPath();
                ctx.roundRect(x + padding, y + padding, gridSize - padding * 2, gridSize - padding * 2, radius);
                ctx.fill();
            });
            
            ctx.shadowBlur = 0;

            // Draw particles
            updateParticles();
            drawParticles();
        }

        // Game step
        function gameStep() {
            update();
            draw();
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            clearInterval(gameLoop);
            
            // Create death particles
            createParticles(snake[0].x, snake[0].y, 'rgba(255, 0, 85, 1)');
            draw();

            // Check high score
            const isNewHighScore = score > highScore;
            if (isNewHighScore) {
                highScore = score;
                localStorage.setItem('neonSerpentHighScore', highScore);
                highScoreEl.textContent = highScore;
            }

            // Show overlay
            setTimeout(() => {
                overlayTitle.textContent = 'GAME OVER';
                overlayMessage.textContent = 'The serpent has fallen';
                finalScore.textContent = score;
                finalScore.style.display = 'block';
                newHighScore.style.display = isNewHighScore ? 'block' : 'none';
                playBtn.textContent = 'PLAY AGAIN';
                overlay.classList.remove('start');
                overlay.classList.add('visible');
            }, 300);
        }

        // Start game
        function startGame() {
            overlay.classList.remove('visible');
            initGame();
            gameRunning = true;
            gameLoop = setInterval(gameStep, speed);
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning && (e.code === 'Space' || e.code === 'Enter')) {
                startGame();
                return;
            }

            const keyMap = {
                'ArrowUp': { x: 0, y: -1, key: 'keyUp' },
                'ArrowDown': { x: 0, y: 1, key: 'keyDown' },
                'ArrowLeft': { x: -1, y: 0, key: 'keyLeft' },
                'ArrowRight': { x: 1, y: 0, key: 'keyRight' },
                'KeyW': { x: 0, y: -1, key: 'keyW' },
                'KeyS': { x: 0, y: 1, key: 'keyS' },
                'KeyA': { x: -1, y: 0, key: 'keyA' },
                'KeyD': { x: 1, y: 0, key: 'keyD' }
            };

            const mapping = keyMap[e.code];
            if (mapping) {
                e.preventDefault();
                
                // Visual feedback
                const keyEl = document.getElementById(mapping.key);
                if (keyEl) {
                    keyEl.classList.add('active');
                    setTimeout(() => keyEl.classList.remove('active'), 100);
                }

                // Prevent 180-degree turns
                if (direction.x + mapping.x !== 0 || direction.y + mapping.y !== 0) {
                    nextDirection = { x: mapping.x, y: mapping.y };
                }
            }
        });

        // Touch controls
        document.querySelectorAll('.touch-btn[data-dir]').forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameRunning) return;
                
                const dirMap = {
                    'up': { x: 0, y: -1 },
                    'down': { x: 0, y: 1 },
                    'left': { x: -1, y: 0 },
                    'right': { x: 1, y: 0 }
                };
                
                const dir = dirMap[btn.dataset.dir];
                if (direction.x + dir.x !== 0 || direction.y + dir.y !== 0) {
                    nextDirection = { ...dir };
                }
            });
        });

        // Play button
        playBtn.addEventListener('click', startGame);

        // Initial draw
        initGame();
        draw();
    </script>
</body>
</html>
